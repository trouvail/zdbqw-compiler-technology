那么接下来就由我进行讲解，再说说头文件部分，(type.h)首先我们增加了布尔类型，(Instruction.h)在指令方面增加了函数调用、零扩展等指令，零扩展主要是为了将bool值与int值进行匹配，然后这个AllocaInstruction2是为了分配全局变量定义的，需要与局部变量区分开来。(Ast.h)在建立语法树中增加了回填错误列表，并在二元表达式中增加乘除、大于等于等操作符，并与上次相同增加一些比如函数元素声明，while循环、函数调用等新状态。
 
定义文件部分的话，(SymbolTable.cpp)在符号表部分增加了与上次相同的查找函数，(main.cpp)在主函数部分首先定义四个表项分别是输入输出字符和数字，因为检查文件中有需要输入输出，所以相当于预定义了四个函数，{(Function.cpp)在函数的部分首先是其输出加上了参数列表，如果其参数不为空的话，需要在括号后输出}，(BasicBlock.cpp)在基本块的定义中增加了插入部分，就是相当于插入指令的时候需要补上前驱和后继关系，(Instruction.cpp)在指令定义方面，首先把增加的乘除模等运算补充上，然后仿照局部变量的分配方式来写全局变量的分配，主要是输出中得改为全局变量的输出，{接下来对于函数调用方面，首先将操作数储存，然后放入各个参数，输出时也是仿照函数定义，只不过这次换成了call}；零扩展指令是先将操作储存并将bool的一位扩展至32位，余位补零，输出是按照标准文件里进行输出的，将目的数赋值为其零扩展；异或指令也是类似，建立操作数，并付给其相应的关系，输出也是标准文件的输出。
 
(Ast.cpp)最后也是最为重点的部分，首先是回填函数中需要增加指令的前驱和后继关系，然后仿照回填函数写的条件错误的回填也是类似的实现，只不过在后面调用时逻辑更清楚。在二元表达式上首先在原先的代码基础上增加了前驱后继关系，然后仿照和运算写出或运算，其也具有短路的特性，当第一个表达式为真时，整个表达式的值为真，第二个表达式不会执行，然后将在这个函数下创建的falseBB基本块回填，这个也是第二个表达式要插入的位置，然后生成表达式2的代码，当前也是不能确定表达式2的falselist和两个表达式的truelist，所以都将其插入到当前节点中，让父节点回填；对于小于大于等指令与其类似，他们的错误和正确列表都由父节点进行回填；对于加减等指令没太大变化，增加了乘除法等。
 
在if生成代码时，也是增加了前驱后继付给关系的语句，ifelse仿照if，在此函数下先声明三个基本块，并为其增加前驱后继关系，将then填充到正确列表，else填充到错误列表，然后生成then和else的代码，最后设置end为插入点为后续进行插入，seqnode就是让其两个状态先后生成代码即可；在标识符定义处，由于有多个标识符，所以设置一个for循环，内部代码与原先类似，在全局变量增加了查找，如果可以找到的话就直接生成代码，否则为其赋值一个常量，如果是局部变量的话就分配内存就可以了，后面的for循环是生成局部变量的代码；对于while循环，首先在当前函数下生成三个基本块和前驱后继关系，并将循环体填入到正确跳转，结束的位置填入到错误跳转，然后生成循环体，并设置后续插入节点；接下来常量的声明与刚才类似，只不过对于全局变量是一定能查找到的，就不用条件判断了，对于局部变量因为必须先赋值，所以就得将其储存。{对于单目表达式如果是感叹号就将其取反，如果是正负号的话就判断类型，布尔值进行零扩充然后与零相加减}
 
接下来是类型检查部分，根节点直接递归调用，二元表达式首先判断两个子式是否为void，如果是void类型直接报错退出，接下来判断其是否相等，不等的话也直接报错退出。然后是条件判断的地方需要看其是否是布尔值，如果不是就报错退出，对于if、ifelse、while都是如此，其内容直接递归判断；对于seqnode为递归调用两个子式；对于返回值类型需要检查其是否为空；对于赋值语句需要判断左右两类型是否相同；{单目运算其类型也不能是void}，输出部分与上次语法分析类似，在这里就不在赘述，我的讲解到此结束，谢谢老师。