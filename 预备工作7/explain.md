# 编译器讲解
（SSA static single assignment 静态单赋值：每个变量只能被赋值一次）
（指令前加v代表是NEON双精度d0-d31和VFP单精度s0-s31共享的指令，扩展寄存器，maybe用于浮点数的计算）
（bl memset /r0:目的 r1:值 r2:长度/设置从r0开始r2长度的空间为r1）
（lsl asl lsr asr 逻辑和算术的左右移 ）
（vmsr vmrs为在ARM寄存器和NEON或VFP寄存器间传递内容）
（VCVT为在单精度和双精度之间进行转换）
（lr连接寄存器，一般为r14，非叶函数和叶函数翻译时会有不同，13是sp寄存器，11是fp寄存器）
## 实现基本的 IR 指令到汇编指令的翻译，完善 genMachineCode() 函数（基本要求）

> 数据访存指令的翻译，主要只需要完成 StoreInstruction

由于本次实现了浮点数，所以在加载指令部分需要补充上浮点数，基本上照着整型变量做即可，例如加载全局变量，也是先从标签处将其地址加载到寄存器中，然后从刚加载到寄存器的地址获取值即可，只不过要用vldr

（Instruction.cpp）
然后看存储指令，首先判断是整型还是浮点类型，生成对应的操作，如果是存储到一个标签地址中，则需要先将此地址加载到寄存器中，方便后边的存储；然后如果是局部变量，先获得偏移，然后以基址寄存器FP加上偏移，如果有溢出需要重新加载其地址，然后根据对应的类型进行存储；对于全局变量来说，先加载标签对应的地址，然后根据此地址进行存储；对于指针变量来说即数组元素，直接进行存储即可

（MachineCode.cpp）

在其机器码的部分是仿照加载指令，构造时直接将传参赋值，输出时不论是str指令还是vstr指令都是先输出存储的寄存器，然后输出其基地址，如果有偏移的话再将偏移也输出。


> 二元运算指令的翻译，BinaryInstrction

（Instruction.cpp）
接下来在二元指令生成机器码部分，由于浮点类型和整型部分相似，所以说一下浮点类型，首先生成三个部分的操作数，中间代码允许两个操作数都可以是立即数，但汇编代码中却不被允许，为了方便不判断是否有几个立即数，所以只要出现立即数，就先将其加载到寄存器中，然后赋予一个临时寄存器，接下来根据相应的类型生成对应的指令即可

（MachineCode.cpp）

二元运算指令的机器码，其构造函数也是直接将传参赋值并加入使用列表和设置父节点，输出函数首先将其对应的操作输出，比如加减乘除等，然后输出存储到的寄存器以及相操作的两个数（但不会是两个立即数）


> 比较指令的翻译

（Instruction.cpp）
再看比较指令，也是说浮点型，首先也是当其为立即数的时候放照二元运算指令需要先将其存储到一个寄存器中，然后生成比较指令，为了之后的跳转指令做铺垫，所以需要对其操作进行判断，如果是大于，小于等操作，其为假的分支就是在7下互补的指令，如果是等于，则为假的分支是不等，不等的指令也类似；然后整型部分和浮点部分类似

（MachineCode.cpp）

然后是比较指令的翻译，初始化的操作也是直接传参即可，然后判断比较的类型，随后将比较的两个数输出即可实现


> 控制流指令的翻译，UncondBrInstr 语句、CondBrInstr 语句、RetInstru 语句等

（Instruction.cpp）
对于控制流指令，对于UncondBrInstr直接生成一条无条件跳转即可，上面的部分是仿照genMachineCode生成汇编代码部分的块号；对于CondBrInstr，由于其一定在比较指令之后，所以由于刚在比较指令的部分已经为其做了铺垫，所以在此直接根据其true或false分支进行跳转即可

再看RetInstr，首先如果有返回值，需要生成MOV指令，将返回值保存在R0寄存器，浮点数保存在16号寄存器中，由于整型变量大小有一定的限制，所以当其超过时需要对其重新进行加载；接下来生成add指令恢复栈帧，最后生成跳转指令返回caller

（MachineCode.cpp）

关于控制流指令的输出直接将跳转的类型和跳转的地方输出即可，如果有条件的话打印条件，控制流指令的构造的话也是先传参，然后如果是BL指令，为带链接的跳转，须保存PC当前内容，需要设置好整数和浮点数的寄存器，将其添加到定义列表，然后根据跳转到的参数个数来决定是否将其添加到使用列表；接下来如果是BX指令，为带状态切换的跳转，保存状态参数即可


> 函数定义及函数调用的翻译

（Instruction.cpp）
接下来是函数调用，由于有数组可能初始化为全零，所以如果是直接赋值全零的话，其余操作与调用类似，只是直接赋值全零即可，然后讲普通函数的调用操作，先对参数的个数进行计算，根据参数个数判断是否进行push操作来传递参数，然后分别对整型和浮点型的变量进行判断其个数是否超过了5，接下来对超过相应部分的参数进行压栈操作，并记录相应的压栈的个数，最后生成一个bl跳转指令，保存了pc相应内容，为非叶函数做铺垫，然后根据刚才记录的个数来为其分配栈空间，最后如果结果被用到需要根据其类型在相应的寄存器中保存返回值

（MachineCode.cpp）

对于其机器码，首先说一下栈操作，先根据操作输出相应类型，然后判断使用列表的大小，如果小于16则代表没有浮点操作，直接根据大小输出相应寄存器，否则需要将相应的浮点类型寄存器也输出

接下来看函数，先看构造部分，根据参数个数来赋予相应的整型和浮点型的个数，如果大于四个则需要将其压入栈中，并且根据压入栈的个数判断是否需要对齐；再看输出部分，首先生成push指令保存FP寄存器以及一些called saved寄存器，然后生成mov指令使得FP寄存器指向新栈底，接下来需要生成sub指令为局部变量分配栈内空间，如果参数大于四个的话需要调用内存空间，然后对每个基本块进行输出

对于基本块的输出，先输出其对应的块编号，然后对每条指令进行判断，如果是普通的指令，则直接将其输出即可，对于类似存储或者二元指令有加载常量或者是全局变量的时候需要先将其加载到寄存器中，然后再将其输出，对于bx指令则需要弹出相应保存的值


## 进阶要求

> 实现数组的翻译

对于进阶要求里，首先是数组的翻译，在语法分析（Parser.y）部分，由VarDeclStmt和ConstDeclStmt来生成，主要是类型和名字列表，名字列表VarDefList又由每一个VarDef组成，VarDef可以是单一变量或者是数组变量或加上赋值，对于数组变量需要考虑中括号ArrayIndices,其里面的值为常量，普通变量直接将其存入到符号表中，数组变量需要根据中括号的个数确定其维度并初始化为全零，如果需要赋值的话与之类似，将相应的值从栈中取出赋予即可，常量数组的赋值与之类似，但其在声明的时候就需要赋于其相应的值，不能有空值常量；

在数组类型转换字符串中（type.cpp的ArrayType::toStr），根据数组的维度输出几叉几叉，然后根据数组的类型将其赋到后面并输出中括号以及乘号，在指令中（instruction.cpp GepInstruction）,构造时对其进行传参，然后输出时先输出getelementptr inbounds（越界检查）,然后输出初始指针类型，指针的基址的类型以及一组索引的类型等，在语法树（AST.cpp I’d:gencode）中，如果是一个多维数组的话，则循环每一个维度，如果没有全局的赋值则需要为其声明一个临时变量，然后如果到最后一个直接退出循环，否则改变目的指针并进行下一次的循环，当其数组为右值的话还需要一条加载指令，如果是一个一维数组的话，则直接判断是否有提前声明，没有的话为其声明一个临时变量，否则直接赋值即可，生成数组指令

（Instruction.cpp GepInstruction::genMachineCode）
在数组指令生成机器码的时候，如果是初始化，则赋予其栈空间并返回即可，也需要对偏移进行大小的判断，然后如果是立即数需要将其先加载到寄存器中，如果是最开始的维度，则直接赋于大小即可，否则将其加载到寄存器中，根据是否是全局变量来将其不同的方式加载，随后根据指针的类型来计算其相应的大小，然后根据此值大小重新复制给寄存器，最后如果不是最终的维度，则需要递归调用数组指令生成汇编代码；如果是最后一个维度，则根据其是否是全局变量来将其不同的方式存储


> 实现浮点类型的翻译

然后是浮点类型的翻译，首先在词法和语法分析部分直接仿照整型变量对其进行添加即可，并将float加入类型当中，之后在各种操作中都需要进行判断是整型还是浮点类型，根据类型的不同进行相应的操作，（AST.cpp）比如在二元指令的计算，数组各个维度类型的判断，函数的参数等，生成中间代码的时候也需要根据浮点或者是整型来判断是float还是i32，最后生成机器码时通过对float的判断来决定是arm指令还是NEON/VFP指令，相应的判断是否寄存到扩展寄存器中，对于浮点类型的指令比如有vadd,vsub,vmsr,vcvt,vldr等，根据相应的情况进行判断即可，在生成机器码的时候在基本要求里已经讲过了，就不再说了


> 实现 break、continue 语句的翻译

对于break和continue语句，由于其并不会出现在循环的外部，所以在语法分析阶段（parser.y）就对齐进行检查，如果没有在while循环的结构体中，直接报错；在语法树（Ast.cpp），不论是（continueStmt）在break还是continue都会生成无条件跳转指令，然后通过while父节点判断跳转的地方，进行跳转即可，在while中设置相应的回填和基本块


> 实现非叶函数的翻译

最后是非叶函数，其和叶函数一个最重要的不同是需要保存更多的寄存器，所以其序言和尾声的实现方式会不同，非叶函数的序言需要将更多的寄存器保存到堆栈中，比如需要保存lr寄存器，在尾声方面，遇到叶函数就分支到存储在LR寄存器中的地址，而遇到非叶函数是直接pop到PC寄存器

我的讲解到此结束